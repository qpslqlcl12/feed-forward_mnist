import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
import numpy as np
import time


np.set_printoptions(precision=6, suppress=True)
(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()
x_train = x_train.reshape(60000, 784).astype("float32") / 255
x_test = x_test.reshape(10000, 784).astype("float32") / 255
#print("xtrain", x_train[31])
#print("ytrain", y_train[31])

#support data set
data_0=x_train[1]
data_1=x_train[3]
data_2=x_train[5]
data_3=x_train[7]
data_4=x_train[2]
data_5=x_train[0]
data_6=x_train[13]
data_8=x_train[17]
data_9=x_train[4]

#query data set
Qdata_0=x_train[21]
Qdata_1=x_train[6]
Qdata_2=x_train[16]
Qdata_3=x_train[10]
Qdata_4=x_train[9]
Qdata_5=x_train[11]
Qdata_6=x_train[18]
Qdata_7=x_train[15]
Qdata_8=x_train[31]
Qdata_9=x_train[19]


#label for 4 way 
way_0 = tf.Variable([1.,0.,0.,0.])
way_1 = tf.Variable([0.,1.,0.,0.])
way_2 = tf.Variable([0.,0.,1.,0.])
way_3 = tf.Variable([0.,0.,0.,1.])

empty_label = tf.Variable([0.,0.,0.,0.])

w1=[]
w2=[]
encoder_buffer=[]
TCAM_buffer=[]
#reverse_prediction=[]
TCAM_array=[]
backward_output=[]
support_data_set=[]
query_input=[]

loss_fn=tf.keras.losses.MeanSquaredError()
opt=tf.keras.optimizers.Adam(learning_rate=0.01)

def data_preprocessing():
    
    data_00=tf.concat([way_0,data_0],0)
    data_11=tf.concat([way_1,data_1],0)
    data_33=tf.concat([way_2,data_3],0)
    data_55=tf.concat([way_3,data_5],0)

    data_00=tf.expand_dims(data_00,0)
    data_11=tf.expand_dims(data_11,0)
    data_33=tf.expand_dims(data_33,0)
    data_55=tf.expand_dims(data_55,0)    

    support_data_set.append(data_00)
    support_data_set.append(data_11)
    support_data_set.append(data_33)
    support_data_set.append(data_55)

    Qdata_00=tf.concat([empty_label,Qdata_0],0)
    query=tf.expand_dims(Qdata_00,0)
    
    return query

def network_initializer():   
    w1=tf.Variable(tf.random.uniform([788,400],-1,1), trainable=True, name='w1')      
    w2=tf.Variable(tf.random.uniform([400,10],-1,1), trainable=True, name='w2')
    return w1, w2

def forward_pass(input,w1,w2):
    h1=tf.matmul(input,w1)    
    h1=tf.keras.activations.sigmoid(h1)    
    out=tf.matmul(h1,w2)
    out=tf.keras.activations.sigmoid(out)
    return out,w1,w2

def backward_pass(encoder_buffer,w1,w2):
    w2=tf.transpose(w2)
    h1=tf.matmul(encoder_buffer,w2)
    h1=tf.keras.activations.sigmoid(h1)
    w1=tf.transpose(w1)
    input=tf.matmul(h1,w1)
    input=tf.keras.activations.sigmoid(input)
    return input

def contrastive_loss(encoded_query_data, retrieved_TCAM_data, similar, Dw):
    margin=1.25
    #print("marginho")
    loss_value=(similar)*(0.5)*(tf.square(Dw))+(1-similar)*tf.square((0.5)*(tf.math.maximum(0.,margin-Dw)))
    #print(loss_value)
    return loss_value

def grad(query_input,w1,w2,loss):
    with tf.GradientTape() as tape:
        out,w1,w2=forward_pass(query_input,w1,w2)   
    dw1, dw2 = tape.gradient(loss,[w1,w2])   
    return dw1,dw2
 
def TCAM_store(encoded_data):
    TCAM_array.append(encoded_data)
    return 0
  
def TCAM_retrieve(encoded_query_data):
    dist1=[]
    dist2=[100.]     
    for stored_data in TCAM_array:
        #print("stored:",stored_data)
        dist1.append(Minkowski_distance(encoded_query_data, stored_data))
    min_dist_value=min(dist1)
    min_dist_index=dist1.index(min_dist_value)
    return TCAM_array[min_dist_index], min_dist_value

def Minkowski_distance(x,y):
    dist=tf.sqrt(tf.reduce_sum(tf.square(x-y)))    
    return dist


query_input=data_preprocessing()
#sequence
w1, w2 = network_initializer()




#store support set
for support_input in support_data_set:
    encoder_buffer,w1,w2 = forward_pass(support_input, w1, w2)
    TCAM_store(encoder_buffer)

#print("q",query_input)
#print(support_data_set)

#query
encoder_buffer,w1,w2 = forward_pass(query_input,w1,w2)
TCAM_buffer, distance_btw_query_mostsimilarTCAM = TCAM_retrieve(encoder_buffer)
#backward pass
backward_output=backward_pass(TCAM_buffer,w1,w2)
print("way_0:",way_0)
print("backward_output:", tf.slice(backward_output,[0,0],[1,4]))


#print("query_input:", query_input)
#print("encoder_buffer:",encoder_buffer)
#print("TCAM_buffer:",TCAM_buffer)
#print("TCAM_array:",TCAM_array)



#training
c_loss=contrastive_loss(encoder_buffer,TCAM_buffer,1,distance_btw_query_mostsimilarTCAM)
print("closs:", c_loss)
grad_weight1, grad_weight2=grad(query_input,w1,w2,c_loss)
print("grad:", grad_weight1)
opt.apply_gradients(zip([grad_weight1,grad_weight2],[w1,w2]))




